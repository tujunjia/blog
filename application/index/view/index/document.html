{include file="public/head,public/nav"}
<body style="background-color: #F7F7F7">
<div class="container">
    <div class="row">
        <!--左侧-->
        <div class="col-md-8">
            <div class="document-body-left">
                <!--下面是文章内容的展示-->
                <h1 id="1">进程状态</h1>
                <p class="document-body-left-p">Linux是一个多用户，多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，而每个进程会有不同的状态。(总结起来就是以下五种状态)</p>
                <p class="document-body-left-p" style="color: red">Linux进程状态：R (TASK_RUNNING)，可执行状态。</p>
                <p class="document-body-left-p">只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。</p>
                <p class="document-body-left-p" style="color: red">Linux进程状态：S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。</p>
                <P class="document-body-left-p">处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</P>
                <p class="document-body-left-p" style="color: red">Linux进程状态：D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。</p>
                <P class="document-body-left-p"> 与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。</P>
                <p class="document-body-left-p" style="color: red">Linux进程状态：T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。</p>
                <p class="document-body-left-p"> 向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。</p>
                <p class="document-body-left-p" style="color: red">Linux进程状态：Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。</p>
                <p class="document-body-left-p"> 进程在退出的过程中，处于TASK_DEAD状态。<br>在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p>
                <hr/>
                <h1>父进程与子进程</h1>
                <p class="document-body-left-p">节点一的内容节点一的内容节点一的内容节点一的内容节点一的内容节点一的内容节点一的内容节点一的内容</p>
                <hr/>
                <h1>前台进程与后台进程</h1>
                <p class="document-body-left-p">节点一的内容节点一的内容节点一的内容节点一的内容</p>
                <hr/>
                <h1>进程常用命令</h1>
                <p class="document-body-left-p">节点一的内容节点一的内容节点一的内容节点一的内容</p>
                <hr/>
                <h1>总结</h1>
                <p class="document-body-left-p">节点一的内容节点一的内容节点一的内容节点一的内容</p>
            </div>
        </div>
    <!--右侧-->
        <div class="col-md-4 ">
            <div>
                <!--目录的div-->
                <div class="body-background body-background-nav">
                    <div class="body-background-nav-position" >
                        <p style="font-size: 2em">目录</p>
                        <hr>
                        <div class="document-right-a">
                            <p><a href="#1" style="text-decoration: none">1 进程状态</a></p>
                            <p><a href="#2" style="text-decoration: none">2 父进程与子进程</a></p>
                            <p><a href="#3" style="text-decoration: none">3 前台进程与后台进程</a></p>
                            <p><a href="#4" style="text-decoration: none">4 进程常用命令</a></p>
                            <p><a href="#5" style="text-decoration: none">5 总结</a></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
<script>
    $(function() {
        var elm = $('.body-background-nav');
        var startPos = $(elm).offset().top;
        $.event.add(window, "scroll", function() {
            var p = $(window).scrollTop();
            $(elm).css('position',((p) > startPos) ? 'fixed' : 'static');
            $(elm).css('top',((p) > startPos) ? '0px' : '');
            $(elm).css('width',((p) > startPos) ? '360px' : '');
            $(elm).css('float',((p) > startPos) ? 'clear' : '');
        });
    });
</script>
{include file="public/footer"}
